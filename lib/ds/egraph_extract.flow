import ds/egraph;
import math/math;

export {
	// Extracts the cheapest enode for each class
	extractEGraph(e : EGraph<?>, costFn : (ENode<?>, [EClassCost<?>]) -> EClassCost<?>) -> Tree<int,  EClassCost<?>>;

	EClassCost(
		// The cost of this
		cost : int,
		// The node that wins
		node : ENode<?>
	);
}

ExtractorEnv(
	egraph : EGraph<?>,
	costFn : (ENode<?>, [EClassCost<?>]) -> EClassCost<?>,
	// The cheapest cost so far per class
	costs : ref Tree<int, EClassCost<?>>,
	// What eclasses are we currently extracting? Attempt to avoid infinite loops
	extracting : ref Set<int>,
);

// https://github.com/egraphs-good/egg/blob/main/src/extract.rs
extractEGraph(e : EGraph<?>, costFn : (ENode<?>, [EClassCost<?>]) -> EClassCost<?>) -> Tree<int,  EClassCost<?>> {
	env = ExtractorEnv(e, costFn, ref makeTree(), ref makeSet());
	calcEClassCosts(env);
	^(env.costs);
}

calcEClassCosts(e : ExtractorEnv<?>) -> void {
	work = ref false;
	roots = getEClasses(e.egraph);
	iterSet(roots, \eclass : int -> {
		getEClassCost(e, eclass);
		{}
	});
	if (^work) {
		calcEClassCosts(e);
	}
}

getEClassCost(env : ExtractorEnv<?>, eclass : int) -> Maybe<EClassCost<?>> {
	mcost = lookupTree(^(env.costs), eclass);
	mcost ?? {
		Some(mcost)
	} : {
		if (containsSet(^(env.extracting), eclass)) None()
		else {
			env.extracting := insertSet(^(env.extracting), eclass);
			nodes = getEClassNodes(env.egraph, eclass);
			res = foldSet(nodes, mcost, \acc, node -> {
				ncost = getENodeCost(env, node);
				switch (ncost) {
					None(): acc;
					Some(cost): {
						switch (acc) {
							None(): {
								env.costs := setTree(^(env.costs), eclass, cost);
								Some(cost);
							}
							Some(ec): {
								if (cost.cost < ec.cost) {
									env.costs := setTree(^(env.costs), eclass, cost);
									Some(cost);
								} else acc;
							}
						}
					}
				}
			});
			env.extracting := removeSet(^(env.extracting), eclass);

			res;
		}
	}
}

getENodeCost(env : ExtractorEnv<?>, node : ENode<?>) -> Maybe<EClassCost<?>> {
	childcosts = filtermap(node.args, \arg -> {
		getEClassCost(env, arg)
	});
	if (length(childcosts) == length(node.args)) {
		cost = env.costFn(node, map(childcosts, \cc -> cc));
		Some(cost);
	} else None();
}
